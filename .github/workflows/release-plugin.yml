name: Release Plugin

on:
  push:
    tags:
      - 'v*'  # Triggers on version tags like v1.2.3

jobs:
  release:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: Extract version from tag
      shell: pwsh
      run: |
        $tagName = "${{ github.ref_name }}"
        $version = $tagName -replace '^v', ''
        Write-Output "RELEASE_VERSION=$version" >> $env:GITHUB_ENV
        Write-Output "TAG_NAME=$tagName" >> $env:GITHUB_ENV
    
    - name: Generate release notes from PRs
      shell: pwsh
      run: |
        $tagName = "${{ env.TAG_NAME }}"
        
        # Find previous tag
        $allTags = git tag --sort=-version:refname
        $currentIndex = $allTags.IndexOf($tagName)
        $previousTag = if ($currentIndex -lt ($allTags.Count - 1)) { $allTags[$currentIndex + 1] } else { $null }
        
        # Get commits between tags
        $commits = @()
        if ($previousTag) {
            $commits = git log --oneline "$previousTag..$tagName"
        } else {
            $commits = git log --oneline -10
        }
        
        # Extract PR numbers and fetch PR descriptions
        $prNumbers = @()
        $changelog = @()
        
        foreach ($commit in $commits) {
            if ($commit -match '#(\d+)') {
                $prNumbers += $matches[1]
            } else {
                # Non-PR commit
                $changelog += "- $commit"
            }
        }
        
        # Fetch PR details from GitHub API
        $headers = @{
            'Authorization' = 'token ${{ secrets.GITHUB_TOKEN }}'
            'Accept' = 'application/vnd.github.v3+json'
        }
        
        foreach ($prNumber in ($prNumbers | Sort-Object -Unique)) {
            try {
                $prUrl = "https://api.github.com/repos/${{ github.repository }}/pulls/$prNumber"
                $response = Invoke-RestMethod -Uri $prUrl -Headers $headers -Method Get
                
                $title = $response.title
                $body = $response.body
                $user = $response.user.login
                
                # Format PR entry
                $prEntry = "- **$title** (#$prNumber by @$user)"
                if ($body -and $body.Trim()) {
                    $prEntry += "`n  " + ($body -split "`n" | Select-Object -First 2 | Join-String -Separator "`n  ")
                }
                $changelog += $prEntry
            } catch {
                $changelog += "- PR #$prNumber"
            }
        }
        
        if ($changelog.Count -eq 0) {
            $changelog = @("- Initial release")
        }
        
        $changelogText = $changelog -join "`n"
        Write-Output "CHANGELOG<<EOF" >> $env:GITHUB_ENV
        Write-Output $changelogText >> $env:GITHUB_ENV
        Write-Output "EOF" >> $env:GITHUB_ENV
    
    - name: Update version files
      shell: pwsh
      run: |
        $version = "${{ env.RELEASE_VERSION }}"
        
        # Update manifest XML
        $manifestPath = "sagutidloader.xml"
        if (Test-Path $manifestPath) {
            [xml]$manifest = Get-Content $manifestPath -Encoding UTF8
            $manifest.extension.version = $version
            $manifest.Save((Resolve-Path $manifestPath).Path)
            Write-Host "Updated manifest version to $version"
        }
        
        # Update package.json
        $packagePath = "package.json"
        if (Test-Path $packagePath) {
            $package = Get-Content $packagePath -Encoding UTF8 | ConvertFrom-Json
            $package.version = $version
            $package | ConvertTo-Json -Depth 10 | Set-Content $packagePath -Encoding UTF8
            Write-Host "Updated package.json version to $version"
        }
        
        # Update service worker version
        $swPath = "assets/ts/serviceworker.ts"
        if (Test-Path $swPath) {
            $content = Get-Content $swPath -Raw -Encoding UTF8
            $content = $content -replace "const VERSION = '[^']*'", "const VERSION = '$version'"
            Set-Content $swPath $content -NoNewline -Encoding UTF8
            Write-Host "Updated service worker version to $version"
        }
    
    - name: Build production assets
      run: npm run build:prod
    
    - name: Package plugin
      shell: pwsh
      run: |
        $manifestPath = "sagutidloader.xml"
        [xml]$manifest = Get-Content $manifestPath -Encoding UTF8
        $pluginName = "sagutidloader"
        
        # Create clean staging directory
        $stageDir = "build/$pluginName"
        if (Test-Path $stageDir) { Remove-Item $stageDir -Recurse -Force }
        New-Item -ItemType Directory -Path $stageDir -Force | Out-Null
        
        # Copy manifest first
        Copy-Item $manifestPath "$stageDir/" -Force
        Write-Host "Copied manifest: $manifestPath"
        
        # Process files from manifest
        $filesNode = $manifest.extension.files
        if ($filesNode) {
            Write-Host "Processing manifest files section..."
            foreach ($node in $filesNode.ChildNodes) {
                if ($node.NodeType -eq [System.Xml.XmlNodeType]::Element) {
                    $tag = $node.Name.ToLower()
                    $text = [string]$node.InnerText
                    
                    if ([string]::IsNullOrWhiteSpace($text)) { continue }
                    
                    switch ($tag) {
                        'filename' {
                            if (Test-Path $text) {
                                Copy-Item $text "$stageDir/" -Force
                                Write-Host "Copied filename: $text"
                            } else {
                                Write-Warning "Missing filename: $text"
                            }
                        }
                        'file' {
                            if (Test-Path $text) {
                                $dest = "$stageDir/$text"
                                $parent = Split-Path $dest -Parent
                                if (-not (Test-Path $parent)) { 
                                    New-Item -ItemType Directory -Path $parent -Force | Out-Null 
                                }
                                Copy-Item $text $dest -Force
                                Write-Host "Copied file: $text"
                            } else {
                                Write-Warning "Missing file: $text"
                            }
                        }
                        'folder' {
                            if (Test-Path $text) {
                                Copy-Item $text "$stageDir/$text" -Recurse -Force
                                Write-Host "Copied folder: $text"
                            } else {
                                Write-Warning "Missing folder: $text"
                            }
                        }
                    }
                }
            }
        }
        
        # Add .well-known/assetlinks.json if generated
        $assetLinksPath = ".well-known/assetlinks.json"
        if (Test-Path $assetLinksPath) {
            $wellKnownDir = "$stageDir/.well-known"
            if (-not (Test-Path $wellKnownDir)) {
                New-Item -ItemType Directory -Path $wellKnownDir -Force | Out-Null
            }
            Copy-Item $assetLinksPath "$wellKnownDir/" -Force
            Write-Host "Copied assetlinks.json"
        }
        
        # Create ZIP
        $zipPath = "$pluginName.zip"
        if (Test-Path $zipPath) { Remove-Item $zipPath -Force }
        
        Push-Location $stageDir
        try {
            Compress-Archive -Path * -DestinationPath "../../$zipPath" -Force
            Write-Host "Created ZIP: $zipPath"
        } finally {
            Pop-Location
        }
        
        # Verify ZIP contents
        Write-Host "`nZIP Contents:"
        Add-Type -AssemblyName System.IO.Compression.FileSystem
        $zip = [System.IO.Compression.ZipFile]::OpenRead((Resolve-Path $zipPath).Path)
        try {
            $zip.Entries | ForEach-Object { Write-Host "  $($_.FullName)" }
        } finally {
            $zip.Dispose()
        }
        
        Write-Output "ZIP_PATH=$zipPath" >> $env:GITHUB_ENV
    
    - name: Generate update server XML
      shell: pwsh
      run: |
        $version = "${{ env.RELEASE_VERSION }}"
        $zipPath = "${{ env.ZIP_PATH }}"
        $changelog = "${{ env.CHANGELOG }}"
        
        # Create updates directory
        $updatesDir = "updates"
        if (-not (Test-Path $updatesDir)) {
            New-Item -ItemType Directory -Path $updatesDir | Out-Null
        }
        
        # Generate URLs
        $downloadUrl = "https://github.com/${{ github.repository }}/releases/download/${{ env.TAG_NAME }}/$zipPath"
        $changelogUrl = "https://github.com/${{ github.repository }}/releases/tag/${{ env.TAG_NAME }}"
        
        # Read manifest for accurate metadata
        $manifestPath = "sagutidloader.xml"
        [xml]$manifest = Get-Content $manifestPath -Encoding UTF8
        
        $pluginName = $manifest.extension.name
        $phpFileNode = $manifest.extension.SelectSingleNode('files/filename[contains(., ".php")]')
        if ($phpFileNode) {
            $element = [string]$phpFileNode.InnerText -replace '\.php$', ''
        } else {
            $element = "sagutidloader"
        }
        
        # Calculate checksums for the ZIP file
        Write-Host "Calculating checksums for $zipPath..."
        $sha256Hash = (Get-FileHash -Path $zipPath -Algorithm SHA256).Hash.ToLower()
        $sha1Hash = (Get-FileHash -Path $zipPath -Algorithm SHA1).Hash.ToLower()
        $md5Hash = (Get-FileHash -Path $zipPath -Algorithm MD5).Hash.ToLower()
        $fileSize = (Get-Item $zipPath).Length
        
        Write-Host "SHA256: $sha256Hash"
        Write-Host "SHA1: $sha1Hash" 
        Write-Host "MD5: $md5Hash"
        Write-Host "Size: $fileSize bytes"
        
        # Create update XML content
        $updateFile = "$updatesDir/sagutidloader_updates.xml"
        
        # Build XML content line by line to avoid YAML multiline issues
        $xmlLines = @(
            '<?xml version="1.0" encoding="utf-8"?>',
            '<updates>',
            '    <update>',
            "        <name>PLG_SYSTEM_SAGUTIDLOADER</name>",
            "        <description><![CDATA[$changelog]]></description>",
            "        <element>$element</element>",
            '        <type>plugin</type>',
            '        <folder>system</folder>',
            '        <client>0</client>',
            "        <version>$version</version>",
            "        <infourl title=`"Plugin Info`">$changelogUrl</infourl>",
            '        <downloads>',
            "            <downloadurl type=`"full`" format=`"zip`" size=`"$fileSize`" sha256=`"$sha256Hash`" sha1=`"$sha1Hash`" md5=`"$md5Hash`">$downloadUrl</downloadurl>",
            '        </downloads>',
            "        <changelogurl>$changelogUrl</changelogurl>",
            '        <targetplatform name="joomla" version="4.*" />',
            '        <targetplatform name="joomla" version="5.*" />',
            '        <php_minimum>7.4</php_minimum>',
            '    </update>',
            '</updates>'
        )
        
        $xmlLines | Set-Content $updateFile -Encoding UTF8
        Write-Host "Generated update server XML: $updateFile"
        Write-Host "Download URL: $downloadUrl"
    
    - name: Update version files on main branch via GitHub API
      shell: pwsh
      run: |
        # Files to update on main branch (from bump-version.ps1)
        $filesToUpdate = @(
          @{ path = "updates/sagutidloader_updates.xml"; message = "Update XML with checksums and metadata" },
          @{ path = "sagutidloader.xml"; message = "Bump version in manifest" },
          @{ path = "package.json"; message = "Bump version in package.json" },
          @{ path = "assets/ts/serviceworker.ts"; message = "Bump version in service worker" }
        )
        
        $headers = @{
            "Authorization" = "token ${{ secrets.GITHUB_TOKEN }}"
            "Accept" = "application/vnd.github.v3+json"
        }
        
        foreach ($fileInfo in $filesToUpdate) {
          $filePath = $fileInfo.path
          $commitMessage = $fileInfo.message
          
          Write-Host "Updating $filePath on main branch..."
          
          # Check if file exists locally
          if (-not (Test-Path $filePath)) {
            Write-Host "File $filePath not found locally, skipping..."
            continue
          }
          
          $fileContent = Get-Content $filePath -Raw -Encoding UTF8
          $base64Content = [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($fileContent))
          
          # Get current file SHA from main branch
          $apiUrl = "https://api.github.com/repos/${{ github.repository }}/contents/$filePath"
          
          try {
            $currentFile = Invoke-RestMethod -Uri $apiUrl -Headers $headers -Method GET
            $currentSha = $currentFile.sha
            Write-Host "Current SHA for $filePath: $currentSha"
            
            # Check if content is different to avoid unnecessary commits
            $currentContent = [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($currentFile.content.Replace("`n", "").Replace("`r", "")))
            if ($currentContent.Trim() -eq $fileContent.Trim()) {
              Write-Host "Content for $filePath unchanged, skipping update"
              continue
            }
          } catch {
            Write-Host "File $filePath doesn't exist on main branch yet"
            $currentSha = $null
          }
          
          # Update file on main branch
          $updateBody = @{
            message = "Release ${{ github.ref_name }}: $commitMessage"
            content = $base64Content
            branch = "main"
          }
          
          if ($currentSha) {
            $updateBody.sha = $currentSha
          }
          
          $updateJson = $updateBody | ConvertTo-Json -Depth 10
          
          try {
            $result = Invoke-RestMethod -Uri $apiUrl -Headers $headers -Method PUT -Body $updateJson -ContentType "application/json"
            Write-Host "Successfully updated $filePath on main branch"
            Write-Host "New commit SHA: $($result.commit.sha)"
          } catch {
            Write-Host "Failed to update $filePath`: $_"
            if ($_.Exception.Response) {
              $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
              $responseBody = $reader.ReadToEnd()
              Write-Host "Response body: $responseBody"
            }
          }
        }
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ env.TAG_NAME }}
        name: "Release ${{ env.RELEASE_VERSION }}"
        body: |
          ## 🎉 What's New
          ${{ env.CHANGELOG }}
          
          ## 📦 Installation
          Download `${{ env.ZIP_PATH }}` and install via Joomla's Extension Manager.
          
          ## 🔄 Automatic Updates
          This release updates the update server XML for automatic plugin updates in Joomla.
          
          Update server URL: `https://raw.githubusercontent.com/${{ github.repository }}/main/updates/sagutidloader_updates.xml`
        files: |
          ${{ env.ZIP_PATH }}
          updates/sagutidloader_updates.xml
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}